对，这题我建议你两种都理解一遍，但面试时你只需要熟练写出其中一种就够了（通常快慢指针更“面试友好”，set 更直观）。


---

1）set / visited（最好理解）

想法：只要某个 n 再次出现，就说明进入循环了 → 不快乐。

优点：最直观、几乎不可能写错

缺点：用额外空间


bool isHappy(int n) {
    unordered_set<int> seen;
    while (n != 1 && !seen.count(n)) {
        seen.insert(n);
        n = getnext(n);
    }
    return n == 1;
}

（或者用 vector<bool> vis(1000) 也行，理由是一次变换后 n 很小。）


---

2）快慢指针（Floyd 判圈，最好背一套模板）

把这个过程看成函数迭代：n -> f(n)，就像链表 next。

slow 每次走一步：slow = f(slow)

fast 每次走两步：fast = f(f(fast))

如果有环，一定会相遇；如果到 1，fast 会先到 1


bool isHappy(int n) {
    int slow = n;
    int fast = getnext(n);
    while (fast != 1 && slow != fast) {
        slow = getnext(slow);
        fast = getnext(getnext(fast));
    }
    return fast == 1;
}

优点：O(1) 额外空间，模板通用

缺点：第一次写容易把 fast 初始化/循环条件写乱



---

面试建议

你现在阶段：先用 set/vis 写稳（保证正确 + 解释简单）。

然后再把 Floyd 模板记熟：以后遇到“函数迭代判环”能秒写。


如果你愿意，我可以把“这类题统一模板”总结成 3 行口诀（如何初始化 slow/fast、循环条件、返回条件），你背一次以后基本不会写错。
